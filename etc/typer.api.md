## API Report File for "@typeskill/typer"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Component } from 'react';
import { ComponentType } from 'react';
import { FunctionComponent } from 'react';
import { ScrollViewProps } from 'react-native';
import { StyleProp } from 'react-native';
import { TextStyle } from 'react-native';
import { ViewStyle } from 'react-native';

// @public
export namespace Attributes {
    export type GenericValue = object | TextValue | undefined;
    export type LineType = 'normal' | 'quoted';
    export interface Map {
        // (undocumented)
        readonly [k: string]: GenericValue;
    }
    export type TextValue = boolean | string | number | null;
}

// @public
export interface BlockOp<T extends object> extends GenericOp {
    readonly attributes?: Attributes.Map;
    readonly insert: T;
}

// @public
export namespace Bridge {
    export type AttributesOverrideListener = (attributeName: string, attributeValue: Attributes.GenericValue) => void;
    export type ControlEvent = 'APPLY_ATTRIBUTES_TO_SELECTION' | 'INSERT_OR_REPLACE_AT_SELECTION';
    export interface ControlEventDomain<ImageSource> {
        applyTextTransformToSelection: (attributeName: string, attributeValue: Attributes.TextValue) => void;
        // @internal
        insertOrReplaceAtSelection: (element: Element<ImageSource>) => void;
    }
    export type Element<ImageSource> = ImageElement<ImageSource> | TextElement;
    export interface ImageElement<Source> {
        // (undocumented)
        description: Images.Description<Source>;
        // (undocumented)
        type: 'image';
    }
    // @internal (undocumented)
    export type InsertOrReplaceAtSelectionListener<ImageSource> = <D extends {}>(element: Element<ImageSource>) => void;
    export type LineTypeOverrideListener = (lineType: Attributes.LineType) => void;
    export type SelectedAttributesChangeListener = (selectedAttributes: Attributes.Map) => void;
    // @internal
    export interface SheetEventDomain<ImageSource> {
        addApplyTextTransformToSelectionListener: (owner: object, listener: AttributesOverrideListener) => void;
        addInsertOrReplaceAtSelectionListener: (owner: object, listener: InsertOrReplaceAtSelectionListener<ImageSource>) => void;
        release: (owner: object) => void;
    }
    // (undocumented)
    export interface TextElement {
        // (undocumented)
        content: string;
        // (undocumented)
        type: 'text';
    }
}

// @public
export interface Bridge<ImageSource> {
    getControlEventDomain: () => Bridge.ControlEventDomain<ImageSource>;
    // @internal
    getSheetEventDomain: () => Bridge.SheetEventDomain<ImageSource>;
    release: () => void;
}

// @public (undocumented)
export const Bridge: {};

// @public
export function buildBridge<ImageSource>(): Bridge<ImageSource>;

// @public
export function buildEmptyDocument(): Document;

// @public
export function buildVectorIconControlSpec<A extends GenericControlAction, T extends Toolbar.VectorIconMinimalProps>(IconComponent: ComponentType<T & Toolbar.TextControlMinimalIconProps>, actionType: A, name: string, options?: Pick<Toolbar.GenericControlSpec<A, T>, 'actionOptions' | 'iconProps'>): Toolbar.GenericControlSpec<A, T>;

// @public
export function cloneDocument(content: Document): Document;

// @public
export const CONTROL_SEPARATOR: unique symbol;

// @public (undocumented)
export const defaultTextTransforms: Transforms.GenericSpec<Attributes.TextValue, 'text'>[];

// @public
export interface Document {
    readonly currentSelection: SelectionShape;
    readonly lastDiff: GenericOp[];
    readonly ops: GenericOp[];
    readonly schemaVersion: number;
    readonly selectedTextAttributes: Attributes.Map;
}

// @public
export enum DocumentControlAction {
    INSERT_IMAGE_AT_SELECTION = 4,
    SELECT_TEXT_BOLD = 0,
    SELECT_TEXT_ITALIC = 1,
    SELECT_TEXT_STRIKETHROUGH = 3,
    SELECT_TEXT_UNDERLINE = 2
}

// @public
export interface DocumentRendererProps<ImageSource> {
    contentContainerStyle?: StyleProp<ViewStyle>;
    document: Document;
    documentStyle?: StyleProp<ViewStyle>;
    ImageComponent?: Images.Component<ImageSource>;
    maxMediaBlockHeight?: number;
    maxMediaBlockWidth?: number;
    ScrollView?: ComponentType<any>;
    scrollViewProps?: ScrollViewProps;
    spacing?: number;
    style?: StyleProp<ViewStyle>;
    textStyle?: StyleProp<TextStyle>;
    textTransformSpecs?: Transforms.Specs<'text'>;
}

// @public (undocumented)
export interface FocusableInput {
    focus: () => void;
}

// @public
export type GenericControlAction = string | symbol | number;

// @public
export interface GenericOp {
    readonly attributes?: Attributes.Map;
    // @internal
    readonly delete?: number;
    readonly insert?: string | object;
    // @internal
    readonly retain?: number;
}

// @public
export interface GenericRichContent {
    // (undocumented)
    readonly length: () => number;
    readonly ops: GenericOp[];
}

// @public
export interface ImageKind<Source> extends Images.Description<Source> {
    // (undocumented)
    kind: 'image';
}

// @public
export type ImageOp<Source> = BlockOp<ImageKind<Source>>;

// @public
export namespace Images {
    // (undocumented)
    export type Component<Source> = ComponentType<ComponentProps<Source>>;
    // (undocumented)
    export interface ComponentProps<Source> {
        readonly description: Description<Source>;
        readonly printDimensions: Dimensions;
    }
    // (undocumented)
    export interface Description<Source> {
        // (undocumented)
        readonly height: number;
        // (undocumented)
        readonly source: Source;
        // (undocumented)
        readonly width: number;
    }
    // (undocumented)
    export interface Dimensions {
        // (undocumented)
        readonly height: number;
        // (undocumented)
        readonly width: number;
    }
    export interface Hooks<Source> {
        readonly onImageAddedEvent?: (description: Description<Source>) => void;
        readonly onImageRemovedEvent?: (description: Description<Source>) => void;
    }
    // (undocumented)
    export interface StandardSource {
        // (undocumented)
        uri: string;
    }
}

// @public
export namespace Print {
    export type Props<ImageSource> = DocumentRendererProps<ImageSource>;
}

// @public
export class Print<ImageSource = Images.StandardSource> extends Component<Print.Props<ImageSource>> {
}

// @public
export interface SelectionShape {
    readonly end: number;
    readonly start: number;
}

// @public
export interface TextOp extends GenericOp {
    readonly attributes?: Attributes.Map;
    readonly insert?: string;
}

// @public
export namespace Toolbar {
    export type DocumentControlSpec<T extends object = {}> = GenericControlSpec<DocumentControlAction, T>;
    // (undocumented)
    export interface GenericControlSpec<A extends GenericControlAction, T extends object> {
        actionOptions?: any;
        actionType: A;
        IconComponent: ComponentType<TextControlMinimalIconProps & T>;
        iconProps?: T extends Toolbar.VectorIconMinimalProps ? Toolbar.VectorIconMinimalProps : Partial<T>;
    }
    export interface IconButtonProps extends IconButtonSpecs {
        // (undocumented)
        IconComponent: ComponentType<TextControlMinimalIconProps>;
        // (undocumented)
        iconProps?: object;
        // (undocumented)
        onPress?: () => void;
        // (undocumented)
        selected: boolean;
        // (undocumented)
        style?: StyleProp<ViewStyle>;
    }
    // (undocumented)
    export interface IconButtonSpecs {
        activeButtonBackgroundColor: string;
        activeButtonColor: string;
        iconSize: number;
        inactiveButtonBackgroundColor: string;
        inactiveButtonColor: string;
    }
    export type Layout = (DocumentControlSpec<any> | typeof CONTROL_SEPARATOR | GenericControlSpec<any, any>)[];
    export interface Props<ImageSource, ImageOptions = any> extends Partial<IconButtonSpecs> {
        bridge: Bridge<ImageSource>;
        buttonSpacing?: number;
        contentContainerStyle?: StyleProp<ViewStyle>;
        document: Document;
        layout: Layout;
        onInsertImageError?: (e: Error) => void;
        onPressCustomControl?: <A extends GenericControlAction>(actionType: A, actionOptions?: any) => void;
        pickOneImage?: (options?: ImageOptions) => Promise<Images.Description<ImageSource>>;
        separatorColor?: string;
        style?: StyleProp<ViewStyle>;
    }
    export interface TextControlMinimalIconProps {
        color?: string;
        size?: number;
    }
    export interface VectorIconMinimalProps {
        name: string;
    }
}

// @public
export class Toolbar<ImageSource = Images.StandardSource, ImageOptions = any> extends Component<Toolbar.Props<ImageSource, ImageOptions>> {
    IconButton: FunctionComponent<Toolbar.IconButtonProps>;
}

// @public
export namespace Transforms {
    export type BoolSpec<T extends TargetType = 'block'> = GenericSpec<true, T>;
    // @internal
    export interface Dict<A extends Attributes.GenericValue, T extends TargetType> {
        // (undocumented)
        [attributeName: string]: GenericSpec<A, T>[];
    }
    export interface GenericSpec<A extends Attributes.GenericValue, T extends TargetType> {
        activeAttributeValue: A;
        activeStyle: T extends 'block' ? ViewStyle : TextStyle;
        attributeName: string;
    }
    // (undocumented)
    export type Specs<T extends 'text' | 'block' = 'text'> = GenericSpec<Attributes.TextValue, T>[];
    export type TargetType = 'block' | 'text';
    export type TextAttributeName = 'bold' | 'italic' | 'textDecoration';
}

// @public
export class Transforms {
    constructor(textTransformSpecs: Transforms.GenericSpec<Attributes.TextValue, 'text'>[]);
    // @internal
    getStylesFromOp(op: TextOp): StyleProp<TextStyle>;
    }

// @public
export namespace Typer {
    export interface Props<ImageSource> extends DocumentRendererProps<ImageSource> {
        androidDisableMultipleAttributeEdits?: boolean;
        bridge: Bridge<ImageSource>;
        debug?: boolean;
        disableSelectionOverrides?: boolean;
        imageHooks?: Images.Hooks<ImageSource>;
        onDocumentUpdate?: (nextDocumentContent: Document) => void;
        readonly?: boolean;
        underlayColor?: string;
    }
}

// @public
export class Typer<ImageSource = Images.StandardSource> extends Component<Typer.Props<ImageSource>> implements FocusableInput {
    // (undocumented)
    focus: () => void;
}


```
